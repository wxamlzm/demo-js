// 给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var longestOnes = function (nums, k) {
  let l = 0,
    r = 0

  while (r < nums.length) {
    if (nums[r++] === 0) {
      k--
    }

    // 只要k小于0，l就右移
    if (k < 0 && nums[l++] === 0) {
      k++
    }
  }
  console.log(r, l)
  return r - l
}

let nums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0],
  k = 2
longestOnes(nums, k)

// 是的，这个写法维护的是一个只能单调变长的窗口。这种窗口经常出现在寻求”最大窗口“的问题中：
// 因为要求的是”最大“，所以我们没有必要缩短窗口，于是代码就少了缩短窗口的部分；
// 从另一个角度讲，本题里的K是消耗品，一旦透支，窗口就不能再增长了（也意味着如果K == 0还是有可能增长的）。
// 所以K所代表的”资源“，通常是滑窗维护逻辑的核心，能这么写有两个先决条件：
// 固定一个左端点，K随窗口增大是单调变化的。据此我们可以推知长度为n的窗口如若已经”透支“（K < 0）了，那么长度大于n的也一定不符合条件；
// K的变化与数组元素有简单的算术关系。向窗口纳入（A[r++]）或移除（A[l++]）一个数组元素，可以在O(1)内更新K。
// 虽说有条件，但仔细排查会发现许多滑窗问题都可以满足。
